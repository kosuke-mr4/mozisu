{"mappings":"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","sources":["node_modules/@parcel/runtime-browser-hmr/lib/runtime-93f7d09574ed46c9.js","src/index.js","node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js","node_modules/preact/jsx-runtime/src/utils.js","node_modules/preact/src/constants.js","node_modules/preact/jsx-runtime/src/index.js","node_modules/preact/dist/preact.module.js","node_modules/preact/src/util.js","node_modules/preact/src/options.js","node_modules/preact/src/create-element.js","node_modules/preact/src/component.js","node_modules/preact/src/diff/props.js","node_modules/preact/src/create-context.js","node_modules/preact/src/diff/children.js","node_modules/preact/src/diff/index.js","node_modules/preact/src/render.js","node_modules/preact/src/clone-element.js","node_modules/preact/src/diff/catch-error.js","node_modules/@parcel/transformer-js/src/esmodule-helpers.js","src/App.js","node_modules/preact/hooks/dist/hooks.module.js","node_modules/preact/hooks/src/index.js"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SECURE = false;var HMR_ENV_HASH = \"d6ea1d42532a7575\";var HMR_USE_SSE = false;module.bundle.HMR_BUNDLE_ID = \"890e741a975ef6c8\";\"use strict\";\n\n/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: {|[string]: mixed|};\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ninterface ExtensionContext {\n  runtime: {|\n    reload(): void,\n    getURL(url: string): string;\n    getManifest(): {manifest_version: number, ...};\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\ndeclare var HMR_USE_SSE: boolean;\ndeclare var chrome: ExtensionContext;\ndeclare var browser: ExtensionContext;\ndeclare var __parcel__import__: (string) => Promise<void>;\ndeclare var __parcel__importScripts__: (string) => Promise<void>;\ndeclare var globalThis: typeof self;\ndeclare var ServiceWorkerGlobalScope: Object;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData[moduleName],\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData[moduleName] = undefined;\n}\nmodule.bundle.Module = Module;\nmodule.bundle.hotData = {};\nvar checkedAssets /*: {|[string]: boolean|} */, assetsToDispose /*: Array<[ParcelRequire, string]> */, assetsToAccept /*: Array<[ParcelRequire, string]> */;\n\nfunction getHostname() {\n  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\nfunction getPort() {\n  return HMR_PORT || location.port;\n}\n\n// eslint-disable-next-line no-redeclare\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = getHostname();\n  var port = getPort();\n  var protocol = HMR_SECURE || location.protocol == 'https:' && !['localhost', '127.0.0.1', '0.0.0.0'].includes(hostname) ? 'wss' : 'ws';\n  var ws;\n  if (HMR_USE_SSE) {\n    ws = new EventSource('/__parcel_hmr');\n  } else {\n    try {\n      ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');\n    } catch (err) {\n      if (err.message) {\n        console.error(err.message);\n      }\n      ws = {};\n    }\n  }\n\n  // Web extension context\n  var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;\n\n  // Safari doesn't support sourceURL in error stacks.\n  // eval may also be disabled via CSP, so do a quick check.\n  var supportsSourceURL = false;\n  try {\n    (0, eval)('throw new Error(\"test\"); //# sourceURL=test.js');\n  } catch (err) {\n    supportsSourceURL = err.stack.includes('test.js');\n  }\n\n  // $FlowFixMe\n  ws.onmessage = async function (event /*: {data: string, ...} */) {\n    checkedAssets = {} /*: {|[string]: boolean|} */;\n    assetsToAccept = [];\n    assetsToDispose = [];\n    var data /*: HMRMessage */ = JSON.parse(event.data);\n    if (data.type === 'update') {\n      // Remove error overlay if there is one\n      if (typeof document !== 'undefined') {\n        removeErrorOverlay();\n      }\n      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH);\n\n      // Handle HMR Update\n      let handled = assets.every(asset => {\n        return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n      });\n      if (handled) {\n        console.clear();\n\n        // Dispatch custom event so other runtimes (e.g React Refresh) are aware.\n        if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n          window.dispatchEvent(new CustomEvent('parcelhmraccept'));\n        }\n        await hmrApplyUpdates(assets);\n\n        // Dispose all old assets.\n        let processedAssets = {} /*: {|[string]: boolean|} */;\n        for (let i = 0; i < assetsToDispose.length; i++) {\n          let id = assetsToDispose[i][1];\n          if (!processedAssets[id]) {\n            hmrDispose(assetsToDispose[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n\n        // Run accept callbacks. This will also re-execute other disposed assets in topological order.\n        processedAssets = {};\n        for (let i = 0; i < assetsToAccept.length; i++) {\n          let id = assetsToAccept[i][1];\n          if (!processedAssets[id]) {\n            hmrAccept(assetsToAccept[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n      } else fullReload();\n    }\n    if (data.type === 'error') {\n      // Log parcel errors to console\n      for (let ansiDiagnostic of data.diagnostics.ansi) {\n        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n        console.error(' [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n      }\n      if (typeof document !== 'undefined') {\n        // Render the fancy html overlay\n        removeErrorOverlay();\n        var overlay = createErrorOverlay(data.diagnostics.html);\n        // $FlowFixMe\n        document.body.appendChild(overlay);\n      }\n    }\n  };\n  if (ws instanceof WebSocket) {\n    ws.onerror = function (e) {\n      if (e.message) {\n        console.error(e.message);\n      }\n    };\n    ws.onclose = function () {\n      console.warn('[parcel]  Connection to the HMR server was lost');\n    };\n  }\n}\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel]  Error resolved');\n  }\n}\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  let errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n  for (let diagnostic of diagnostics) {\n    let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame) => {\n      return `${p}\n<a href=\"/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}\" style=\"text-decoration: underline; color: #888\" onclick=\"fetch(this.href); return false\">${frame.location}</a>\n${frame.code}`;\n    }, '') : diagnostic.stack;\n    errorHTML += `\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n           ${diagnostic.message}\n        </div>\n        <pre>${stack}</pre>\n        <div>\n          ${diagnostic.hints.map(hint => '<div> ' + hint + '</div>').join('')}\n        </div>\n        ${diagnostic.documentation ? `<div> <a style=\"color: violet\" href=\"${diagnostic.documentation}\" target=\"_blank\">Learn more</a></div>` : ''}\n      </div>\n    `;\n  }\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\nfunction fullReload() {\n  if ('reload' in location) {\n    location.reload();\n  } else if (extCtx && extCtx.runtime && extCtx.runtime.reload) {\n    extCtx.runtime.reload();\n  }\n}\nfunction getParents(bundle, id) /*: Array<[ParcelRequire, string]> */{\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n  var parents = [];\n  var k, d, dep;\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n  return parents;\n}\nfunction updateLink(link) {\n  var href = link.getAttribute('href');\n  if (!href) {\n    return;\n  }\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n  newLink.setAttribute('href',\n  // $FlowFixMe\n  href.split('?')[0] + '?' + Date.now());\n  // $FlowFixMe\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href /*: string */ = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n    cssTimeout = null;\n  }, 50);\n}\nfunction hmrDownload(asset) {\n  if (asset.type === 'js') {\n    if (typeof document !== 'undefined') {\n      let script = document.createElement('script');\n      script.src = asset.url + '?t=' + Date.now();\n      if (asset.outputFormat === 'esmodule') {\n        script.type = 'module';\n      }\n      return new Promise((resolve, reject) => {\n        var _document$head;\n        script.onload = () => resolve(script);\n        script.onerror = reject;\n        (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);\n      });\n    } else if (typeof importScripts === 'function') {\n      // Worker scripts\n      if (asset.outputFormat === 'esmodule') {\n        return __parcel__import__(asset.url + '?t=' + Date.now());\n      } else {\n        return new Promise((resolve, reject) => {\n          try {\n            __parcel__importScripts__(asset.url + '?t=' + Date.now());\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n    }\n  }\n}\nasync function hmrApplyUpdates(assets) {\n  global.parcelHotUpdate = Object.create(null);\n  let scriptsToRemove;\n  try {\n    // If sourceURL comments aren't supported in eval, we need to load\n    // the update from the dev server over HTTP so that stack traces\n    // are correct in errors/logs. This is much slower than eval, so\n    // we only do it if needed (currently just Safari).\n    // https://bugs.webkit.org/show_bug.cgi?id=137297\n    // This path is also taken if a CSP disallows eval.\n    if (!supportsSourceURL) {\n      let promises = assets.map(asset => {\n        var _hmrDownload;\n        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(err => {\n          // Web extension fix\n          if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {\n            extCtx.runtime.reload();\n            return;\n          }\n          throw err;\n        });\n      });\n      scriptsToRemove = await Promise.all(promises);\n    }\n    assets.forEach(function (asset) {\n      hmrApply(module.bundle.root, asset);\n    });\n  } finally {\n    delete global.parcelHotUpdate;\n    if (scriptsToRemove) {\n      scriptsToRemove.forEach(script => {\n        if (script) {\n          var _document$head2;\n          (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);\n        }\n      });\n    }\n  }\n}\nfunction hmrApply(bundle /*: ParcelRequire */, asset /*:  HMRAsset */) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        let oldDeps = modules[asset.id][1];\n        for (let dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            let id = oldDeps[dep];\n            let parents = getParents(module.bundle.root, id);\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n      if (supportsSourceURL) {\n        // Global eval. We would use `new Function` here but browser\n        // support for source maps is better with eval.\n        (0, eval)(asset.output);\n      }\n\n      // $FlowFixMe\n      let fn = global.parcelHotUpdate[asset.id];\n      modules[asset.id] = [fn, deps];\n    } else if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\nfunction hmrDelete(bundle, id) {\n  let modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    let deps = modules[id][1];\n    let orphans = [];\n    for (let dep in deps) {\n      let parents = getParents(module.bundle.root, deps[dep]);\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    }\n\n    // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n    delete modules[id];\n    delete bundle.cache[id];\n\n    // Now delete the orphans.\n    orphans.forEach(id => {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\nfunction hmrAcceptCheck(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  }\n\n  // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n  let parents = getParents(module.bundle.root, id);\n  let accepted = false;\n  while (parents.length > 0) {\n    let v = parents.shift();\n    let a = hmrAcceptCheckOne(v[0], v[1], null);\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else {\n      // Otherwise, queue the parents in the next level upward.\n      let p = getParents(module.bundle.root, v[1]);\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n      parents.push(...p);\n    }\n  }\n  return accepted;\n}\nfunction hmrAcceptCheckOne(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      return true;\n    }\n    return hmrAcceptCheck(bundle.parent, id, depsByBundle);\n  }\n  if (checkedAssets[id]) {\n    return true;\n  }\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  assetsToDispose.push([bundle, id]);\n  if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {\n    assetsToAccept.push([bundle, id]);\n    return true;\n  }\n}\nfunction hmrDispose(bundle /*: ParcelRequire */, id /*: string */) {\n  var cached = bundle.cache[id];\n  bundle.hotData[id] = {};\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData[id];\n  }\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData[id]);\n    });\n  }\n  delete bundle.cache[id];\n}\nfunction hmrAccept(bundle /*: ParcelRequire */, id /*: string */) {\n  // Execute the module.\n  bundle(id);\n\n  // Run the accept callbacks in the new version of the module.\n  var cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      var assetsToAlsoAccept = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n      if (assetsToAlsoAccept && assetsToAccept.length) {\n        assetsToAlsoAccept.forEach(function (a) {\n          hmrDispose(a[0], a[1]);\n        });\n\n        // $FlowFixMe[method-unbinding]\n        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);\n      }\n    });\n  }\n}","import { render } from 'preact';\nimport App from './App';\n\nrender(<App />, document.body);",null,"const ENCODED_ENTITIES = /[\"&<]/;\n\n/** @param {string} str */\nexport function encodeEntities(str) {\n\t// Skip all work for strings with no entities needing encoding:\n\tif (str.length === 0 || ENCODED_ENTITIES.test(str) === false) return str;\n\n\tlet last = 0,\n\t\ti = 0,\n\t\tout = '',\n\t\tch = '';\n\n\t// Seek forward in str until the next entity char:\n\tfor (; i < str.length; i++) {\n\t\tswitch (str.charCodeAt(i)) {\n\t\t\tcase 34:\n\t\t\t\tch = '&quot;';\n\t\t\t\tbreak;\n\t\t\tcase 38:\n\t\t\t\tch = '&amp;';\n\t\t\t\tbreak;\n\t\t\tcase 60:\n\t\t\t\tch = '&lt;';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t}\n\t\t// Append skipped/buffered characters and the encoded entity:\n\t\tif (i !== last) out += str.slice(last, i);\n\t\tout += ch;\n\t\t// Start the next seek/buffer after the entity's offset:\n\t\tlast = i + 1;\n\t}\n\tif (i !== last) out += str.slice(last, i);\n\treturn out;\n}\n","/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 16;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 17;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { options, Fragment } from 'preact';\nimport { encodeEntities } from './utils';\nimport { IS_NON_DIMENSIONAL } from '../../src/constants';\n\nlet vnodeId = 0;\n\nconst isArray = Array.isArray;\n\n/**\n * @fileoverview\n * This file exports various methods that implement Babel's \"automatic\" JSX runtime API:\n * - jsx(type, props, key)\n * - jsxs(type, props, key)\n * - jsxDEV(type, props, key, __source, __self)\n *\n * The implementation of createVNode here is optimized for performance.\n * Benchmarks: https://esbench.com/bench/5f6b54a0b4632100a7dcd2b3\n */\n\n/**\n * JSX.Element factory used by Babel's {runtime:\"automatic\"} JSX transform\n * @param {VNode['type']} type\n * @param {VNode['props']} props\n * @param {VNode['key']} [key]\n * @param {unknown} [isStaticChildren]\n * @param {unknown} [__source]\n * @param {unknown} [__self]\n */\nfunction createVNode(type, props, key, isStaticChildren, __source, __self) {\n\tif (!props) props = {};\n\t// We'll want to preserve `ref` in props to get rid of the need for\n\t// forwardRef components in the future, but that should happen via\n\t// a separate PR.\n\tlet normalizedProps = props,\n\t\tref,\n\t\ti;\n\n\tif ('ref' in normalizedProps) {\n\t\tnormalizedProps = {};\n\t\tfor (i in props) {\n\t\t\tif (i == 'ref') {\n\t\t\t\tref = props[i];\n\t\t\t} else {\n\t\t\t\tnormalizedProps[i] = props[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {VNode & { __source: any; __self: any }} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops: normalizedProps,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: --vnodeId,\n\t\t_index: -1,\n\t\t_flags: 0,\n\t\t__source,\n\t\t__self\n\t};\n\n\t// If a Component VNode, check for and apply defaultProps.\n\t// Note: `type` is often a String, and can be `undefined` in development.\n\tif (typeof type === 'function' && (ref = type.defaultProps)) {\n\t\tfor (i in ref)\n\t\t\tif (typeof normalizedProps[i] === 'undefined') {\n\t\t\t\tnormalizedProps[i] = ref[i];\n\t\t\t}\n\t}\n\n\tif (options.vnode) options.vnode(vnode);\n\treturn vnode;\n}\n\n/**\n * Create a template vnode. This function is not expected to be\n * used directly, but rather through a precompile JSX transform\n * @param {string[]} templates\n * @param  {Array<string | null | VNode>} exprs\n * @returns {VNode}\n */\nfunction jsxTemplate(templates, ...exprs) {\n\tconst vnode = createVNode(Fragment, { tpl: templates, exprs });\n\t// Bypass render to string top level Fragment optimization\n\tvnode.key = vnode._vnode;\n\treturn vnode;\n}\n\nconst JS_TO_CSS = {};\nconst CSS_REGEX = /[A-Z]/g;\n\n/**\n * Serialize an HTML attribute to a string. This function is not\n * expected to be used directly, but rather through a precompile\n * JSX transform\n * @param {string} name The attribute name\n * @param {*} value The attribute value\n * @returns {string}\n */\nfunction jsxAttr(name, value) {\n\tif (options.attr) {\n\t\tconst result = options.attr(name, value);\n\t\tif (typeof result === 'string') return result;\n\t}\n\n\tif (name === 'ref' || name === 'key') return '';\n\tif (name === 'style' && typeof value === 'object') {\n\t\tlet str = '';\n\t\tfor (let prop in value) {\n\t\t\tlet val = value[prop];\n\t\t\tif (val != null && val !== '') {\n\t\t\t\tconst name =\n\t\t\t\t\tprop[0] == '-'\n\t\t\t\t\t\t? prop\n\t\t\t\t\t\t: JS_TO_CSS[prop] ||\n\t\t\t\t\t\t  (JS_TO_CSS[prop] = prop.replace(CSS_REGEX, '-$&').toLowerCase());\n\n\t\t\t\tlet suffix = ';';\n\t\t\t\tif (\n\t\t\t\t\ttypeof val === 'number' &&\n\t\t\t\t\t// Exclude custom-attributes\n\t\t\t\t\t!name.startsWith('--') &&\n\t\t\t\t\t!IS_NON_DIMENSIONAL.test(name)\n\t\t\t\t) {\n\t\t\t\t\tsuffix = 'px;';\n\t\t\t\t}\n\t\t\t\tstr = str + name + ':' + val + suffix;\n\t\t\t}\n\t\t}\n\t\treturn name + '=\"' + str + '\"';\n\t}\n\n\tif (\n\t\tvalue == null ||\n\t\tvalue === false ||\n\t\ttypeof value === 'function' ||\n\t\ttypeof value === 'object'\n\t) {\n\t\treturn '';\n\t} else if (value === true) return name;\n\n\treturn name + '=\"' + encodeEntities(value) + '\"';\n}\n\n/**\n * Escape a dynamic child passed to `jsxTemplate`. This function\n * is not expected to be used directly, but rather through a\n * precompile JSX transform\n * @param {*} value\n * @returns {string | null | VNode | Array<string | null | VNode>}\n */\nfunction jsxEscape(value) {\n\tif (\n\t\tvalue == null ||\n\t\ttypeof value === 'boolean' ||\n\t\ttypeof value === 'function'\n\t) {\n\t\treturn null;\n\t}\n\n\tif (typeof value === 'object') {\n\t\t// Check for VNode\n\t\tif (value.constructor === undefined) return value;\n\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tvalue[i] = jsxEscape(value[i]);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn encodeEntities('' + value);\n}\n\nexport {\n\tcreateVNode as jsx,\n\tcreateVNode as jsxs,\n\tcreateVNode as jsxDEV,\n\tFragment,\n\t// precompiled JSX transform\n\tjsxTemplate,\n\tjsxAttr,\n\tjsxEscape\n};\n",null,"import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {preact.ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import { slice } from './util';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == null && options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor == undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.ownerSVGElement !== undefined,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {Component} a\n * @param {Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c;\n\trerenderQueue.sort(depthSort);\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile ((c = rerenderQueue.shift())) {\n\t\tif (c._dirty) {\n\t\t\tlet renderQueueLength = rerenderQueue.length;\n\t\t\trenderComponent(c);\n\t\t\tif (rerenderQueue.length > renderQueueLength) {\n\t\t\t\t// When i.e. rerendering a provider additional new items can be injected, we want to\n\t\t\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t\t\t// single pass\n\t\t\t\trerenderQueue.sort(depthSort);\n\t\t\t}\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value == null ? '' : value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture =\n\t\t\tname !== (name = name.replace(/(PointerCapture)$|Capture$/i, '$1'));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (\n\t\t\tname.toLowerCase() in dom ||\n\t\t\tname === 'onFocusOut' ||\n\t\t\tname === 'onFocusIn'\n\t\t)\n\t\t\tname = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n          name,\n          useCapture ? eventProxyCapture : eventProxy,\n          useCapture\n        );\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (isSvg) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != null && (value !== false || name[4] === '-')) {\n\t\t\tdom.setAttribute(name, value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == null) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {FunctionComponent} */\n\t\tProvider(props) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\t/** @type {Component[]} */\n\t\t\t\tlet subs = [];\n\t\t\t\tlet ctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(c => {\n\t\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType =\n\t\tcontext);\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR, INSERT_VNODE, MATCHED } from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\tnewParentVNode._nextDom = oldDom;\n\tconstructNewChildrenArray(newParentVNode, renderResult, oldChildren);\n\toldDom = newParentVNode._nextDom;\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index === -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, null, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == null && newDom != null) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tif (\n\t\t\tchildVNode._flags & INSERT_VNODE ||\n\t\t\toldVNode._children === childVNode._children\n\t\t) {\n\t\t\t// @ts-expect-error olDom should be present on a DOM node\n\t\t\tif (oldDom && !oldDom.isConnected) {\n\t\t\t\toldDom = getDomSibling(oldVNode);\n\t\t\t}\n\t\t\toldDom = insert(childVNode, oldDom, parentDom);\n\t\t} else if (\n\t\t\ttypeof childVNode.type == 'function' &&\n\t\t\tchildVNode._nextDom !== undefined\n\t\t) {\n\t\t\t// Since Fragments or components that return Fragment like VNodes can\n\t\t\t// contain multiple DOM nodes as the same level, continue the diff from\n\t\t\t// the sibling of last DOM child of this child VNode\n\t\t\toldDom = childVNode._nextDom;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because it\n\t\t// is only used by `diffChildren` to determine where to resume the diff\n\t\t// after diffing Components and Fragments. Once we store it the nextDOM\n\t\t// local var, we can clean up the property. Also prevents us hanging on to\n\t\t// DOM nodes that may have been unmounted.\n\t\tchildVNode._nextDom = undefined;\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\t// TODO: With new child diffing algo, consider alt ways to diff Fragments.\n\t// Such as dropping oldDom and moving fragments in place\n\t//\n\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t// _nextDom property to the nextSibling of its last child DOM node.\n\t//\n\t// `oldDom` contains the correct value here because if the last child\n\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t// node's nextSibling.\n\tnewParentVNode._nextDom = oldDom;\n\tnewParentVNode._dom = firstChildDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(newParentVNode, renderResult, oldChildren) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tconst newChildrenLength = renderResult.length;\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode.constructor === undefined && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : null,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\n\t\t// Handle unmounting null placeholders, i.e. VNode => null in unkeyed children\n\t\tif (childVNode == null) {\n\t\t\toldVNode = oldChildren[skewedIndex];\n\t\t\tif (\n\t\t\t\toldVNode &&\n\t\t\t\toldVNode.key == null &&\n\t\t\t\toldVNode._dom &&\n\t\t\t\t(oldVNode._flags & MATCHED) === 0\n\t\t\t) {\n\t\t\t\tif (oldVNode._dom == newParentVNode._nextDom) {\n\t\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode, false);\n\n\t\t\t\t// Explicitly nullify this position in oldChildren instead of just\n\t\t\t\t// setting `_match=true` to prevent other routines (e.g.\n\t\t\t\t// `findMatchingIndex` or `getDomSibling`) from thinking VNodes or DOM\n\t\t\t\t// nodes in this position are still available to be used in diffing when\n\t\t\t\t// they have actually already been unmounted. For example, by only\n\t\t\t\t// setting `_match=true` here, the unmounting loop later would attempt\n\t\t\t\t// to unmount this VNode again seeing `_match==true`.  Further,\n\t\t\t\t// getDomSibling doesn't know about _match and so would incorrectly\n\t\t\t\t// assume DOM nodes in this subtree are mounted and usable.\n\t\t\t\toldChildren[skewedIndex] = null;\n\t\t\t\tremainingOldChildren--;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\tconst matchingIndex = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t);\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tchildVNode._index = matchingIndex;\n\n\t\toldVNode = null;\n\t\tif (matchingIndex !== -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original === null\n\t\tconst isMounting = oldVNode == null || oldVNode._original === null;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\tskew--;\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex !== skewedIndex) {\n\t\t\tif (matchingIndex === skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else if (matchingIndex > skewedIndex) {\n\t\t\t\tif (remainingOldChildren > newChildrenLength - skewedIndex) {\n\t\t\t\t\tskew += matchingIndex - skewedIndex;\n\t\t\t\t} else {\n\t\t\t\t\tskew--;\n\t\t\t\t}\n\t\t\t} else if (matchingIndex < skewedIndex) {\n\t\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\t\tskew = matchingIndex - skewedIndex;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tskew = 0;\n\t\t\t}\n\n\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t// match the new skew index (i + new skew)\n\t\t\tif (matchingIndex !== i + skew) {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != null && (oldVNode._flags & MATCHED) === 0) {\n\t\t\t\tif (oldVNode._dom == newParentVNode._nextDom) {\n\t\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tparentDom.insertBefore(parentVNode._dom, oldDom || null);\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != null && oldDom.nodeType === 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet x = skewedIndex - 1;\n\tlet y = skewedIndex + 1;\n\tlet oldVNode = oldChildren[skewedIndex];\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\tlet shouldSearch =\n\t\tremainingOldChildren >\n\t\t(oldVNode != null && (oldVNode._flags & MATCHED) === 0 ? 1 : 0);\n\n\tif (\n\t\toldVNode === null ||\n\t\t(oldVNode &&\n\t\t\tkey == oldVNode.key &&\n\t\t\ttype === oldVNode.type &&\n\t\t\t(oldVNode._flags & MATCHED) === 0)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldVNode = oldChildren[x];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldVNode = oldChildren[y];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn y;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n","import {\n\tEMPTY_OBJ,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tRESET_MODE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!c._force &&\n\t\t\t\t\t((c.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\t\tnewVNode._original === oldVNode._original)\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.forEach(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = null;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t: MODE_HYDRATE;\n\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t\t// ^ could possibly be simplified to:\n\t\t\t\t// excessDomChildren.length = 0;\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == null &&\n\t\tnewVNode._original === oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\tnewVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\troot._nextDom = undefined;\n\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tif (nodeType === 'svg') isSvg = true;\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value === !!nodeType &&\n\t\t\t\t(nodeType ? value.localName === nodeType : value.nodeType === 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (nodeType === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tif (isSvg) {\n\t\t\tdom = document.createElementNS('http://www.w3.org/2000/svg', nodeType);\n\t\t} else {\n\t\t\tdom = document.createElement(nodeType, newProps.is && newProps);\n\t\t}\n\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (nodeType === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != null) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (i !== 'key' && !(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, null, value, isSvg);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\ti !== 'key' &&\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], isSvg);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html !== oldHtml.__html &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg && nodeType !== 'foreignObject',\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (\n\t\t\t\tinputValue !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType === 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType === 'option' && inputValue !== oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], false);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked !== undefined && checked !== dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any>} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) {\n\t\t\tapplyRef(r, null, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && vnode._dom != null) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._component = vnode._parent = vnode._dom = vnode._nextDom = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { EMPTY_OBJ } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to render into\n * @param {PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.firstChild\n\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t? oldVNode._dom\n\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n","import { assign, slice } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === undefined && defaultProps !== undefined) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n","/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {VNode} [oldVNode]\n * @param {ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {Component} */\n\tlet component,\n\t\t/** @type {ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","// src/App.js\nimport { useState } from \"preact/hooks\";\n\nfunction App() {\n  const [text, setText] = useState(\"\");\n\n  const handleInput = (e) => {\n    setText(e.target.value);\n  };\n\n  return (\n    <div className=\"container mx-auto mt-8\">\n      <h1 className=\"text-3xl font-bold mb-4 text-center\">mozisu</h1>\n      <div className=\"text-center\">\n        <textarea\n          value={text}\n          onInput={handleInput}\n          className=\"border border-gray-300 rounded-none py-4 px-6 w-full mb-8 text-2xl h-64 mx-4 sm:mx-0\"\n          placeholder=\"\"\n        />\n        <p className=\"text-xl font-bold\">\n          : {Array.from(text.replace(/[\\n\\s]/g, \"\")).length}\n        </p>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",null,"import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet EMPTY = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingValue = EMPTY;\n\t\t\t\thookItem._nextValue = hookItem._pendingArgs = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\tif (hookItem._pendingValue !== EMPTY) {\n\t\t\t\thookItem._value = hookItem._pendingValue;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t\thookItem._pendingValue = EMPTY;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({ _pendingValue: EMPTY });\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = false;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn shouldUpdate || hookState._component.props !== p\n\t\t\t\t\t? prevScu\n\t\t\t\t\t\t? prevScu.call(this, p, s, c)\n\t\t\t\t\t\t: true\n\t\t\t\t\t: false;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tref(createHandle());\n\t\t\t\treturn () => ref(null);\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._pendingValue = factory();\n\t\tstate._pendingArgs = args;\n\t\tstate._factory = factory;\n\t\treturn state._pendingValue;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal.d').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n"],"names":["ENCODED_ENTITIES","encodeEntities","str","length","test","last","i","out","ch","charCodeAt","slice","IS_NON_DIMENSIONAL","vnodeId","isArray","Array","createVNode","type","props","key","isStaticChildren","__source","__self","ref","normalizedProps","vnode","__k","__","__b","__e","__d","undefined","__c","constructor","__v","__i","__u","defaultProps","options","jsxTemplate","templates","Fragment","tpl","exprs","call","arguments","JS_TO_CSS","CSS_REGEX","jsxAttr","name","value","attr","result","prop","val","replace","toLowerCase","suffix","startsWith","jsxEscape","MODE_HYDRATE","isValidElement","rerenderQueue","prevDebounce","defer","depthSort","eventClock","eventProxy","eventProxyCapture","EMPTY_OBJ","EMPTY_ARR","assign","obj","removeNode","node","parentNode","removeChild","createElement","children","original","createRef","current","BaseComponent","context","this","getDomSibling","childIndex","sibling","updateParentDomPointers","child","base","enqueueRender","c","push","process","debounceRendering","renderQueueLength","component","newVNode","oldVNode","oldDom","commitQueue","refQueue","sort","shift","__P","diff","__n","ownerSVGElement","commitRoot","diffChildren","parentDom","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","childVNode","newDom","firstChildDom","oldChildren","newChildrenLength","constructNewChildrenArray","applyRef","isConnected","insert","nextSibling","skewedIndex","matchingIndex","oldChildrenLength","remainingOldChildren","skew","String","findMatchingIndex","unmount","parentVNode","insertBefore","nodeType","toChildArray","some","x","y","setStyle","style","setProperty","dom","oldValue","useCapture","o","cssText","l","_attached","addEventListener","removeEventListener","e","removeAttribute","setAttribute","createEventProxy","eventHandler","_dispatched","event","tmp","isNew","oldProps","oldState","snapshot","clearProcessingException","newProps","provider","componentContext","renderHook","count","newType","outer","contextType","__E","prototype","render","doRender","sub","state","__h","_sb","__s","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","forEach","componentWillUpdate","componentDidUpdate","__r","getChildContext","getSnapshotBeforeUpdate","indexOf","diffElementNodes","diffed","root","cb","newHtml","oldHtml","newChildren","inputValue","checked","localName","document","createTextNode","createElementNS","is","data","childNodes","attributes","__html","innerHTML","skipRemove","r","componentWillUnmount","replaceNode","firstChild","hydrate","cloneElement","createContext","defaultValue","contextId","Consumer","contextValue","Provider","subs","ctx","_props","old","splice","error","errorInfo","ctor","handled","getDerivedStateFromError","setState","componentDidCatch","update","callback","s","forceUpdate","Promise","then","bind","resolve","setTimeout","a","b","currentIndex","currentComponent","previousComponent","prevRaf","currentHook","afterPaintEffects","EMPTY","_options","oldBeforeDiff","oldBeforeRender","oldAfterDiff","oldCommit","oldBeforeUnmount","oldRoot","getHookState","index","hooks","__H","__V","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","action","currentValue","__N","nextValue","_hasScuFromHooks","updateHookState","p","stateHooks","filter","every","prevScu","shouldUpdate","hookItem","prevCWU","useEffect","args","argsChanged","_pendingArgs","useLayoutEffect","useRef","initialValue","useMemo","useImperativeHandle","createHandle","concat","factory","useCallback","useContext","useDebugValue","formatter","useErrorBoundary","errState","err","useId","__m","mask","flushAfterPaintEffects","invokeCleanup","invokeEffect","requestAnimationFrame","afterNextFrame","hasErrored","HAS_RAF","raf","done","clearTimeout","timeout","cancelAnimationFrame","hook","comp","cleanup","oldArgs","newArgs","arg","f"],"version":3,"file":"index.975ef6c8.js.map","sourceRoot":"/__parcel_source_root/"}